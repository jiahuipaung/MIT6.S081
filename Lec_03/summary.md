# 本节概述
回顾上节内容，讨论以下四个方面：
- Isolation。隔离性是设计操作系统组织结构的驱动力。
- Kernel和User mode。这两种模式用来隔离操作系统内核和用户应用程序。
- System calls。系统调用是应用程序能够转换到内核执行的基本方法，这样用户态应用程序才能使用内核服务。
- 最后是以上内容是如何以一种简单的方式在XV6中实现。

# 强隔离性
从没有操作系统，或将操作系统实现为库文件这一反例入手，这种情况下，应用程序会直接与硬件交互。可能会发生以下两种情况：
- 某一进程陷入死循环，永远无法释放CPU，甚至无法运行第三方进程来杀死该进程，即无法实现multiplex；
- 从内存角度来看，两个进程之间没有内存边界，会导致相互覆盖；
以上两点也是要实现操作系统的主要原因，即：multiplex和物理内存隔离

# 操作系统防御性
为了维持所有组件都能正常工作，操作系统需要抵御应用程序的攻击，典型表现为：应用无意或恶意向系统调用中传入错误参数导致操作系统崩溃。
另一方面是，应用程序不能打破对它的隔离，即用户态与内核态之间的隔离。通常需要通过硬件来实现强隔离，一部分是user/kernel mode，kernel mode在RISC-V中被称为Supervisor mode但是其实是同一个东西；第二部分是page table或者虚拟内存（Virtual Memory）。

# 硬件对于强隔离的支持
两个方面：user/kernel mode和虚拟内存
## user/kernel mode
当程序运行在内核态时CPU可以运行特殊权限指令（直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断）、运行在用户态时只能运行普通权限指令（例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等）。

处理器上有flag来指示当前处于哪个mode，该bit必须且只能有特殊权限指令来修改。

> 那么应用程序怎么从用户态切换到内核态呢？

在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。

ECALL会跳转到内核中一个特定，由内核控制的位置。XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。

在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数。

在内核侧实现相应系统调用的位置负责检查用户应用程序是否有权限执行该系统调用

内核会通过硬件设置一个定时器，定时器到期之后会将控制权限从用户空间转移到内核空间，之后内核就有了控制能力并可以重新调度CPU到另一个进程中。
## 虚拟内存
page table将虚拟内存地址与物理内存地址做了对应。

每一个进程都会有自己独立的page table，这样的话，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。

# 宏内核与微内核

内核也被称为可被信任的计算空间（Trusted Computing Base）即TCB。

基本上来说，要被称为TCB，内核首先要是正确且没有Bug的。若有Bug，攻击者可能会利用那个Bug，并将这个Bug转变成漏洞，这个漏洞使得攻击者可以打破操作系统的隔离性并接管内核。

## 宏内核Monolithic Kernel Design
所有的操作系统服务都在内核中实现。
该方案有两方面要考虑：

1. 大量代码携带更多的BUG隐患
2. 各子模块可以更紧密地集成，从而带来更好的性能（主要是各模块之间的通信消耗）

## 微内核Micro Kernel Design
内核保留非常少的几个模块。例如fs称为一个普通的应用程序，用户程序需要调用相关系统调用时，需要在两个mode之间切换两次

- 在user/kernel mode反复跳转带来的性能损耗。
- 在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。

# 内核编译
